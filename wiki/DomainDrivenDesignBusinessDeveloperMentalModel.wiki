#summary Domain Driven Design - Business Developer mental model

<wiki:toc max_depth="2" />

= General introduction =
If You are new to DDD You can quickly grasp general idea by watching this prezi:
[http://prezi.com/woxd5xokf36g/domain-driven-design-a-place-for-everything-and-everything-in-its-place-en Domain Driven Design - A place for everything and everything in its place]

= Technical introduction =

This document describes sample code illustrating DDD techniques. The intention is to present code form the perspective of the business model developer. So we focus on business developers' mental model without digging to deep into engine details.

Idea is that business developers does not need to understand what's under the hood - he or she should rather focus on modeling and well crafted business code.

==Architecture and design visualization using "scalable map"==

Java (and any known language) does not support understanding complex code structures. Neither UML tools do.

Therefore, using [http://prezi.com Prezi], we have created a "scalable map" of both big picture (architecture) and details view (class design).

  * You can watch it [http://prezi.com/hi2dmhfej9zu/ddd-cqrs-sample/ here]
  * You can "play" default road trip or pan and zoom freely using mouse
  * You can click on SVN link and go straight to the code!

==Project Structure==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample SVN Repository] contains project that is structured in the standard Maven way.

===DDD common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd pl.com.bottega.ddd] contains common DDD library (not framework).

Common DDD goodies are:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication application]
    * annotation - annotations used in Application Layer artifacts
      * !ApplicationEvent - tagging annotation, will be used in visual tools
      * !ApplicationService - if You prefer services instead of commands and handlers. Used for tagging but also provides Spring features (this annotations is annotated by Spring annotations)
      * !ApplicationStatefullComponent - for session scoped Spring beans
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain domain]
    * annotations - annotations for all DDD Building Blocks - some of them are just for tagging (will be used by visual analyzers) but some of them are annotated by Spring's annotations that introduces Spring based features like being a Bean. All annotations will be described in detail in [DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer section] of this document.
    * sharedcernel - common model used in all Bounded Contexts
    * infrastructure
      * events - Events Engine implementation, Common technical listeners, annotations for listeners
      * repo - JPA base repositories, that can be handful
      * sagas - Saga Engine implementation
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas sagas] - Saga API - described in later section of this document


===CqRS common classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fcqrs pl.com.bottega.cqrs] contains common CqRS "engine".

Common CqRS goodies are described in the [PART II], because they are just technical details.

===ERP product classes===
Package [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] is The Product - Enterprise Resource Planning class system.

System modules separation at this package level:
  * crm - Client Relationship Management module
  * sagas - Sagas which contains cross module features
  * sales - Sales module - *most examples are implemented in this module*
  * shipping - Shipping module

Modules are independent set of features that can  be used separately and still being valuable.

In this sample, modules are equal to DDD Bounded Context.

===ERP module structure===
Open [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales] module, look at packages structure and follow the description:

Each module is packaged using the same application architecture style (beginning from the top):
  # _webui_ - at the top, web client controllers
  # two separated CqRS stacks:
    * read (presentation) model
      # _presentation_ reading presentation data
    * write (business) model
      # _application_ application logic (handlers or services, listeners, stateful objects)
      # _domain_ - domain model, building blocks
      # _infrastructure_ - technical stuff, repository implementation, technical listeners

===Technical resources===
Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fresources] contains:
  * JDBC and logger properties
  * application service level (no web app stuff) Spring configuration

Folder [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/#main%2Fwebapp] contains web application based on Spring Web MVC. Other client implementations will be provided in the next milestone (Android, Ajax, Remoting, WebService)

==Just one Maven Artifact?==
As You can see project logically contains:
  * common DDD API
  * common DDD implementation
  * common CqRS API
  * common CqRS implementation
  * product modules API
  * product modules and cross module Sagas implementation

All this stuff is stored in one Eclipse Project - one Maven Artifact.

This decision is a trade-off made in sake of simplicity. If You are proficient Maven user, You probably split code into separated artifacts in one hour. But those of You, who are not familiar with Maven should focus on the essence of this project - sample code.

----
----

=Domain Description=
Sample is illustrated in the context of simplified fraction of the ERP system. We have chosen some ERP domains, because they are relatively well known. Everybody has some intuition about Clients, Orders, Products etc. so We don't have to stuck explaining how different domain works (financial, medical etc.)

==Bounded Contexts==
There are three Bounded Context, that are equals to the ERP modules.
This approach:
  * helps to model that is relevant to the specific context
  * supports focus on specific Domain Expert knowledge area
  * avoids creating one big corporate model of Great Unification theory that is de facto meaningless.

Modules are separated at the level of [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp pl.com.bottega.erp] package.

===Sales===
It's about ordering products, calculating rebates, invoicing and analyzing sale trends.
This module contains most sample code. Other modules just illustrates Event communication and are Saga participants.
===CRM===
It's about client relationship management. Client in this module is modeled as a different artifact (another Bounded Context) than in Sales module.
===Shipping===
It's about charging and shipping orders.

==Shared Kernel== 
Shared Kernel contains model common to all Bounded Contexts - [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel pl.com.bottega.ddd.domain.sharedcernel] package.

==WARNING==
ERP model is simplified in sake of educational purpose. If You are developing such a system refer to [Introduction#Modeling_resources Modeling Resources], in particular:
  * Party Archetype
  * CRM Archetype
  * Product Archetype
----
----

=Application Architecture=
Looking at the [DomainDrivenDesignBusinessDeveloperMentalModel#Architecture_and_design_visualization_using_"scalable_map Visual Map] should be helpful at this moment. 
==Two stacks of Layers== 
Each module is build regarding the same architecture style.
Three tier architecture:
  * Client Tier
  * Application Server Tier
  * DB Tier

Application Server Tier is designed in layered fashion (remember that Tier!=Layer). Layers are grouped in two stacks.
One stack is specialized in domain modeling and handling commands, while second is specialized in fast data serving and handling queries.

CqRS convention is to call one stack: Write Model  and second: Read Model. But we prefer call it *Business* and *Presentation* models because in Business model You both write and read data (read data are just not visually presented, used only in processing).

There are Clients on the top of both stacks. Right now only WebApp client is implemented.
Client Tier code is located here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fwebapp

Server Tier code (Sales Module) is located here:
http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fwebui

Looking at the Server Tier, let's focus on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales Sales Module].

application logic (handlers or services, listeners, stateful objects)
domain - domain model, building blocks
infrastructure - technical stuff, repository implementation, technical listeners

===Presentation Stack===
Presentation (read) model is simple. It's just a thin layer specialized in reading data that need to to presented somehow.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fpresentation pl.com.bottega.erp.sales.presentation] Package contains sample:
  * Queries - Search Criteria objects that specify querying parameters.
Notice that [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/ProductSearchCriteria.java ProductSearchCriteria] class is designed in Fluent Interface style. From the client perspective criteria hides domain model properties (name, description) under abstract text.
  * Data Transfer Objects - carries data. They are created per Use Case/User Story or per View. In complex systems they are much better transferring classes than JPA entities because they don't break encapsulation on the model level and contain optimized data that are needed in particular context.
  * Finders - simple services that perform search based on Search Criteria.

In [PART II] we will discuss:
  * Technical details of designing this Stack
  * Techniques of optimization (Special JPA Syntax, pure SQL, Updating by Events, Materialized Views)

===Business Stack===
Business stack layers are described in detail in the following sections:
[DomainDrivenDesignBusinessDeveloperMentalModel#Application_Layer Application Layer]
[DomainDrivenDesignBusinessDeveloperMentalModel#Domain_Layer Domain Layer]
[CqRS_Part_II Infrastructure]
----
==Expressing Design using Custom Annotations==  
While reading the sample code You should notice multiple custom annotations, used to mark
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fannotations DDD Building Blocks]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fapplication%2Fannotation Application Layer objects]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas Sagas]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Events]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java Commands]

Annotations are used to achieve three goals:
  * Tag code - visual analyzer (similar to "scalable map") will be reading them and presenting design graph
  * Some custom annotations are annotated by Spring's annotation. In effect classes annotated by custom annotations gain Spring features (transactions and security). Using custom annotations decouples and globalizes Spring features.
  * CqRS engine (Event, Sagas) rely on some custom annotations.

All custom annotations will be described in detail in later sections of this document.

----
==Inversion of Control techniques==
Application architecture of this sample rely on Inversion of Control principle - famous Hollywood rule: "Don't call Us, we will call You".

It is important to notice that Spring can be easily removed and all of its features can be implemented on Your own.

*Spring features are encapsulated by custom annotations and interfaces.
Implementing IoC features on Your own is described in PART II.*

===Dependency Injection===
DI is basic IoC technique. In this project DI is used only at the application level:
  * Injecting dependencies (Repositories, Services) to Command Handlers
  * Injecting dependencies (Repositories, Services) to Application Services -  If You want to use classic services approach without commands
  * Injecting dependencies (JDBC connection, Entity Manager) to repositories
  * Injecting dependencies (JDBC connection, Entity Manager) to Finders (presentation stack) 

Sample injection:
<code language="java">
@CommandHandlerAnnotation
public class ChangeCustomerStatusCommandHandler implements CommandHandler<ChangeCustomerStatusCommand, Void>{
  @Inject
  private CustomerRepository customerRepository; 
  //..
}
</code>

We decided not to inject dependencies to Aggregates automatically. It could be done using Spring's @Configurable, but we wanted to keep example magic clear. This trade-off makes rewriting our Leaven to different platform easy (Seam, EJB, etc.) 

Manual Aggregate injection is described in [DomainDrivenDesignBusinessDeveloperMentalModel#Aggregate_Dependency_Injection Aggregate Dependency Injection] chapter.

===Events===
Events are stronger than DI technique of inverting control, because they allow to:
  * abstract number of dependencies (many listeners)
  * decouple from time arrow (asynchronous)

We have decided to implement own [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents Event Engine], because Spring's solution forces You to use Spring specific API.

Event engine contains:
  * two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents annotations]
    * EventListener - for listener methods
    * EventListeners - for class containing listener methods - adds Spring Comonent features (DI)
  * just two [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fevents%2Fimpl impl classes]

So Events Engine can be easily enhanced to support asynchronous processing secured by persistent queue.

===Aspect Oriented Programming===
AOP is the strongest IoC technique used in the sample to provide:
  * transactions
  * security

You can use Command style or classic Application Service style. Simply use [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] or [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandler] annotation - they both introduce Spring Security and Transaction Management features.

But implementing Your own "AOP" *is trivial* when using Command style. Simply edit [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java RunEnvironment] class and add Your own features before and after running a handler.


----
----

=Application Layer= 

Application logic orchestrates scenario for "domain actors", who live in lower layer. Application logic also takes care for security and transactions. Application logic can fire application events.
 
We will discuss all sample Application Layer artifacts focusing on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fapplication Sales Module].

==Commands/Services== 
Leaven supports two styles of implementing Application Logic.
Commands and App Services are technically totally different, but mentally can be considered as equivalent.
Commands are powerful, because it's relatively easy to introduce own "AOP" programming model in clean and no-magic way. Using Spring, you can achieve the same feature, but in a transparent, magic way. So if magic scares You or You like to have full control - choose Commands style.

===Application Services===
At first let's look at the "service" style approach.
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/services/PurchaseApplicationService.java PurchaseApplicationService]

<code language="java">
@ApplicationService
public class PurchaseApplicationService {
  @Inject
  private OrderRepository orderRepository;
  //...  
}
</code>

Characteristic:
  * Repository and Factory injection
  * ApplicationEvent Publisher injection
  * SystemUser - stateful (session scoped) application object injection
  * transactions and security features supported by Spring using custom [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationService.java ApplicationService] annotation
  * Service methods realizes parts of User Story/Use Case

Typical method implementation:
  * Load Aggregates from Repositories (or create in Factories)
  * Perform business scenario (sequence of aggregate calls)
  * Eventually create Application Event
  * Save Aggregates in Repository

===Commands and CommandHandlers===
The "command" style is an alternative to the class "service" style.
You always implement a pair - command and it's handler, for example:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/SubmitOrderCommand.java SubmitOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/SubmitOrderCommandHandler.java SubmitOrderCommandHandler]

or
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/CreateOrderCommand.java CreateOrderCommand]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/CreateOrderCommandHandler.java CreateOrderCommandHandler]


Conceptually two classes can be considered as a [http://en.wikipedia.org/wiki/Command_pattern Command Design Pattern]. In our case, commands are sent from different Tier, so they can not contain any logic due the security and coupling reason. Therefore Command Design pattern is split into:
  * Command that just caries input data (kind of DTO)
  * CommandHandler that contains logic.

====Command====
Creating command is simple:
  * usually implement Serializable tagging interface, because command may be send form remote client
  * add fields that holds command parameters
  * You *can* add [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/Command.java @Command] annotation if You want to express following intentions:
    * Client is not interested in immediate result - command can be handled in an asynchronous way. This is just a suggestion for a Server - it can support asynchronous invocations. Use this mode when You want to optimize response time
    * Command is unique and sending it again is considered a mistake (e.g. nervous user clicking many times). Server stores some amount of commands (annotated as unique) that were ran, therefore it can optimize anti-flood mechanism. *This feature is just in sake of optimization. You must implement unique checking on the domain level* (ex. Order can not be accepted twice). Unique mechanism rely on equals method.
    * Unique command can specify how long it should be considered as unique.

<code language="java">
@Command
public class CreateOrderCommand {

    private final List<Long> productIds;

    public CreateOrderCommand(List<Long> productIds) {
        this.productIds = productIds;
    }

    public List<Long> getProductIds() {
        return productIds;
    }
}
</code>

====CommandHandler====
Creating a handler for a command is also pretty straightforward.
  * implement [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandler.java CommandHandler] interface. This interface is generic, so You must specify:
    * class of the Command that is handled - CqRS engine matches Command and Handlers by this parameter
    * result type - handling command may return something to the caller. Naturally, handler that handle asynchronous commands should return java.lang.Void (not the void keyword).
  * You *can* annotate handler with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/handler/CommandHandlerAnnotation.java CommandHandlerAnnotation] if You wan to rely on automatic  Command2Handler matching. This annotation also introduces Spring features (Dependency Injection, Security and Transactions) to the handler, so You don't need to worry about them.

Now implement logic just the same way as in classic [DomainDrivenDesignBusinessDeveloperMentalModel#Application_Services Application Service]: inject required dependencies and orchestrate part of the Use Case/user Story scenario in handle method based on parameters from the Command. You can also fire an Application Event.

<code language="java">
@CommandHandlerAnnotation
public class CreateOrderCommandHandler implements CommandHandler<CreateOrderCommand, Long> {

  @Inject
  private OrderFactory orderFactory;

  @Inject
  private OrderRepository orderRepository;

  //..
</code>

----
==Application Event==
Application Events are characteristic to the specific Use Case/User Story. They model application (not domain) behavior.

To fire such event, simply:
  * inject [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/ApplicationEventPublisher.java ApplicationEventPublisher] to the Command Handler or Application Service
  * create event using any class
    * event usually carries some valuable information
    * event class *can* be annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationEvent.java ApplicationEvent] annotations - consider this as a meta-data that will be analyzed by some cools tools we plan to publish

<code language="java>
@CommandHandlerAnnotation
public class CreateOrderCommandHandler implements CommandHandler<CreateOrderCommand, Long> {

  @Inject
  private ApplicationEventPublisher applicationEventPublisher;

  //..  

  @Override
  public Long handle(CreateOrderCommand command) {
    //..       
    applicationEventPublisher.publish(new ProductAddedToOrderEvent(productId, systemUser.getUserId(), 1));
    //..
  }
}
</code>

In our example application event [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/events/ProductAddedToOrderEvent.java ProductAddedToOrderEvent] models important fact of the application life cycle. Let's assume that in this sample we don't want to model this act on the domain model level.

<code language="java>
@ApplicationEvent
@SuppressWarnings("serial")
public class ProductAddedToOrderEvent implements Serializable{
	
  private Long productid;
	
  private Long clientId;

  private int quantity;

  public ProductAddedToOrderEvent(Long productid, Long clientId, int quantity) {
    this.productid = productid;
    this.clientId = clientId;
    this.quantity = quantity;
  }

  //just getters
}
</code>

Then, [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/listeners/ProductEventsListener.java one of the listeners] stores data about this fact in "spy model" used by the marketing division to do something evil.

<code language="java">
@EventListeners
public class ProductEventsListener {

  @PersistenceContext
  private EntityManager entityManager;
	
  @EventListener(aynchronous=true)
  public void handle(ProductAddedToOrderEvent event){
    entityManager.persist(new OrderedProduct(event.getProductid(), event.getClientId(), event.getQuantity(), new Date()));
  }
}
</code>
----
==Listeners - Bounded Context and Context Mapper== 
Now we will discuss [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fapplication%2Flisteners Application Level Listeners].

One way to integrate modules (which are equal to Bounded Context in this Sample) is to call Application API of the another module.
This approach introduces coupling between Modules.

If You want to reduce coupling, You can introduce events - one of the IoC techniques.
In that case:
  * one module fires Event (rather Domain Event, but Application Event is also possible)
  * other modules can listen to this event - each module can register many listeners per event.

Introducing events results in:
  * loose coupling (which is always good)
  * possibility to react in an asynchronous way
  * potability to introduce plugin oriented architecture - if You want to create flexible platform

===Bounded Context===
Consider class example by Udi Dahan.
There is a [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fcrm CRM Module] which contains a [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/crm/domain/Customer.java Customer Aggregate]. 

CRM module is about managing clients, this Bounded Context is completely different than [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales sales Module].

CRM Client can have its status changed. Requirement is:
 "when client status is changed to VIP, then calculate x% of the rebate to all not-approved-yet orders"
Orders and Rebates are Sales Bounded Context concepts.
If we would perform this operation in the CRM module than we would break context boundary. CRM module would know about Sales details. Probably everyone have worked on a systems we such a module-spaghetti was developed.

===Listener===

In this sample, we want to avoid this kind of problems. Therefore CRM Client does it's own logic, than fires Event [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/crm/domain/events/CustomerStatusChangedEvent.java CustomerStatusChangedEvent]. *This is just a statement about the fact that took place*.

<code language="java">
@Entity
@DomainAggregateRoot
public class Customer extends BaseAggregateRoot{

  public enum CustomerStatus{
    STANDARD, VIP, PLATINUM
  }
	
  @Enumerated(EnumType.STRING)
  private CustomerStatus status;
	
  public void changeStatus(CustomerStatus status){
    if (status.equals(this.status))
      return;
		
    this.status = status;
		
    eventPubslisher.publish(new CustomerStatusChangedEvent(getId(), status));
  }
}
</code>

System can react in many ways on that statement. For example, Sales module can register [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/listeners/CustomerStatusChangedListener.java CustomerStatusChangedListener] to perform *additional business logic*.

<code language="java">
@EventListeners
public class CustomerStatusChangedListener{

  @EventListener(aynchronous=true)	
  public void handle(CustomerStatusChangedEvent event) {
    if (event.getStatus() == CustomerStatus.VIP){
      calculateReabteForAllDraftOrders(event.getCustomerId(), 10);
    }		
  }
  //..
}
</code>

====Indicative mode====
Notice that Events are expressed in an indicative model. Something has happen and we can not reject this fact. We can only perform additional processing.

This is opposite to the Commands, which are expressed in imperative mode and we can always reject a command.

====Asynchronous Event Processing====
Event listeners are just methods annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListener.java EventListener]

You can specify asynchronous attribute to express an intention so that this logic can be calculated later.
*Always think if additional logic must be performed immediately?* Maybe not, than You can optimize request processing time.

<code language="java">
@EventListeners
public class OrderSubmittedListener {

  @EventListener(aynchronous=true)
  public void handle(OrderSubmittedEvent event) {
    System.out.println("Sending mail aboud order: " + event.getOrderId());	
  }
}
</code>

Notice that in case of events, listener is the artifact that express asynchronous intention. It is opposite to the Commands, where commands express this intention and handler has nothing to say in this matter.

====Application Listener as a Context Mapper and Anti-corruption Layer====
You can consider Application Event Listeners as a Context Mappers, because the map concepts from different Bounded Contexts.
If Your Listeners are listening to the events from the legacy systems, they can be also considered as Anti-corruption Layer artifacts.

===Implementation===
Application Level Event Listener can be implemented in two styles:
  * Perform logic using injected dependencies
  * Create a Command and run it via injected [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/cqrs/command/RunEnvironment.java Run Environment]

----
==Sagas== 

Events are very powerful IoC technique, but has some limitations. You can use Event when dealing with dependent facts that took place in Your system. You mentally treat each Event and it's Listeners as an independent objects with no deterministic processing sequence.

What if sequence order matters? What if some process need to be "pushed" by many events?

You need to introduce a Saga mental model to orchestrate complex processes that contains multi-events sequence.

Sagas are just mentioned here to make layer description complete. Detailed description of Saga model is presented at the end of this document.
----
==Stateful Application Objects==
Sometimes You may need to model Application State.

Notice that:
  * state of the Domain Model should be persisted
  * state of the Client Tier is a different aspect

We are talking about Application Layer state. If You need to introduce state, think if You are sure about that. Next, think about persisting this model or using global, distributed cache. But if You decide to use Session as a storage mechanism, then You have easy support. Just annotate classes with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/annotation/ApplicationStatefullComponent.java ApplicationStatefullComponent] and You are done.

Spring will store objects of this class in Http Session. Spring also lets You inject this objects into Singleton Scoped objects using magic trick based on cunning proxy. For example, our CommandHandlers or ApplicationServices are stateless singletons in sake of memory optimization.

Sample contains following Stateful Application Components:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/application/SystemUser.java SystemUser] - common object representing user working with the system. You can inject this objects into CommandHandlers or ApplicationServices, if You need to know who is performing operation. SystemUser is a application concept that abstract form domain entity. This object contains just ID of the domain entity, therefore concept of domain user does not leak into the whole code.
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/ClientBasket.java ClientBasket] is a metaphor of a shopping cart. In this sample, we assume that Shopping cart is not a domain artifact, nor client specific feature. Assumption is that this metaphor models application concept (but in some systems it may be a very important domain concept, or maybe just some feature of some minor client app).

<code language="java">
@ApplicationStatefullComponent
public class ClientBasket implements Serializable{

    private List<Long> productIds = new ArrayList<Long>();

    @EventListener
    public void clearBasketOnSuccessfulOrderCreation(OrderCreatedEvent event) {
        clearBasket();
    }

    public void clearBasket() {
        productIds.clear();
    }

    public void addProduct(Long productId) {
        productIds.add(productId);
    }

    public List<Long> getProductIds() {
        return Collections.unmodifiableList(productIds);
    }
}
</code>

----
----

=Domain Layer=
Now let's focus on the Sales Bounded Context and its [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain Domain Layer].

We will go through all building blocks discussing design decisions and technical solutions.
==Entity==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Product.java Product] is a sample entity.

Worth to notice:
  * In this case, we don't need setters (technically JPA can work on private fields via reflection which is even faster that calling methods)
  * In general, entity contains business methods - but on the other hand do not spread all business code on entities. [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderLine.java Order Line] is a sample Entity that performs business logic - calculates cost based on rebate policy
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainEntity.java DomainEntity] is just a tagging annotation that will be used by cool visualization tools we plan to publish

===Base class===
You *can* consider extending [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseEntity.java BaseEntity].
*If You don't want to couple Your model with Leaven classes, then simply rename and repackage this class*.

Remember that inheritance is not just about pulling code up in the hierarchy! BaseEntity class is used as a polymorphic interface (in the meaning of "api", not java keyword) in the repositories, so we are in tune with [http://en.wikipedia.org/wiki/Liskov_substitution_principle Liskov Substitution Principle]. Therefore inheritance is justified.

Features of BaseEntity:
  * Optimistic Concurrency - @Version annotation
  * Store last modification date
  * Logic delete operation - change flag. You can use Hibernate Filters to automatically filter archived JPA entities
  * equals and hashcode
----
==Aggregate==
Sample Sales Bounded Context contains three Aggregates:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Order.java Order]
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Invoice.java Invoice]

<code language="java">
@Entity
@Table(name = "Orders")
// table name ORDER is not valid in HSQL dialect
@DomainAggregateRoot
public class Order extends BaseAggregateRoot {
 //..
}
</code>
===Encapsulation===
Notice that:
  * Aggregates does not allow to modify all their properties via setters. It may have sense in some cases only.
  * Aggregate state is changed via business methods
  * Some business operations may be not valid in some state (ex. Order.submit()) - therefore they throw domain [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Ferrors errors].
  * Not all getters make sense.

<code language="java">

</code>

====Inner state protection====
Notice that Invoice Aggregate method: getItems returns list of [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/InvoiceLine.java InvoiceLine] entities. But this list is also unidentifiable in order to protect Aggregate from being changed by outer code. 
<code language="java">
@DomainAggregateRoot
@Entity
public class Invoice extends BaseAggregateRoot {
  //..
  @OneToMany(cascade = CascadeType.ALL)
  private List<InvoiceLine> items;
	
  public List<InvoiceLine> getItems() {
    return Collections.unmodifiableList(items);
  }
}
</code>
====Inner model protection====
Notice that Order Aggregate method: addProduct takes Product Entity as an argument, then wraps it with OrderLine. OrderLine is Aggregate's inner implementation detail.

<code language="java">
public void addProduct(Product product, int quantity) {
  checkIfDraft();

  OrderLine line = find(product);

  if (line == null) {
    items.add(new OrderLine(product, quantity, rebatePolicy));
  }
  else {
    line.increaseQuantity(quantity, rebatePolicy);
  }

  recalculate();
}
</code>
===Outside Projections using Value Objects===
In this sample we assume that Order model is unstable - we expect changes in near future. Therefore we want to reduce catastrophe area to Aggregate itself. Domain Expert is not sure about [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderLine.java Order Line] model.

Therefore [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderedProduct.java OrderedProduct] Value Object is introduced as an "adapter" that adopts inner aggregate model to the outer world.

Notice that method Order.getOrderedProducts transforms inner (unstable) aggregate model to the "outer interface" based on OrderedProduct Value Objects. Method return unidentifiable list because changes to this list does not make any sense.
<code language="java">
public List<OrderedProduct> getOrderedProducts() {
  List<OrderedProduct> result = new ArrayList<OrderedProduct>(items.size());

  for (OrderLine line : items) {
    result.add(new OrderedProduct(line.getProduct().getId(), line.getProduct().getName(), line.getQuantity(),
    line.getEffectiveCost(), line.getRegularCost()));
  }

  return Collections.unmodifiableList(result);
}
</code>
===JPA aspects===
Aggregate is an entity from the JPA perspective. JPA can operate on private fields, so getters and setters are not necessary (using them makes sense only sometimes).

====Lazy Loading====
You may consider Eager loading of some aggregated objects. Some aggregated objects are always needed.

On the other hand, Lazy loading does not hurt with <i>n+1 select problem</i>, because in Business Model we usually load just couple on aggregates, so n is relatively small.

<code language="java">
  @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
  private List<OrderLine> items;
</code>

====Cascade Operations====
Cascade operations make sense to most aggregated objects, so You must always consider adding this attribute.

===Base classes===
You *may* consider extending [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] class.

*If You don't want to couple Your model with Leaven classes, then simply rename and repackage this class*.

BaseAggregateRoot is based on BaseEntity - it adds common future, an injected [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/DomainEventPublisher.java DomainEventPublisher].

===Aggregate Dependency Injection===
Aggregates are the main work-horses of the domain. Therefore, they need to delegate some work to dependencies (Domain Services, Policies, Specifications or DomainEventPublisher).

Aggregates *should not* create dependencies by their own. This simply kills testability.

We decided to perform injection manually in Factories and Repositories (described later). Factories and Repostories are the only places where Aggregate can be born, You should not call an Aggregate constructor. Therefore, Factories and Repositories performs injection before they return an Aggregate.

Notice how[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] class supports injection. setEventPubslisher can be called only once - in Repo or Factory. Calling it inside Application Layer will fail.

<code language="java">
@MappedSuperclass
public abstract class BaseAggregateRoot extends BaseEntity {

  @Transient
  protected DomainEventPublisher eventPubslisher;

  public void setEventPubslisher(DomainEventPublisher domainEventPubslisher) {
    if (this.eventPubslisher != null)
      throw new IllegalStateException("Publisher is already set! Probably You have logical error in code");
    this.eventPubslisher = domainEventPubslisher;
  }
}
</code>

There are other ways to do this:
  * No setter, just custom injection annotation checked in Repo and factory - a little dirty in our opinion
  * @Configurable annotation - we do not want do use any magic in sake of architecture style portability. Besides, sometime we need to calculate (perform some business logic) to determine a Policy for example
  * Pass needed dependencies as Aggregate methods' parameters. Sometimes can be artificial, but sometimes makes sense. For example, when dependency is needed only in one method of the Aggregate. But on the other hand - as we discuss later - very specific and used once Aggregate Methods should become a Domain Service.
----
==Value Objects==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel Shared Kernel] contains two examples of Value Objects: Money and Percentage. Both encapsulates representation of the value they protect.
Therefore You can change money calculations to ultra-fast integers where fractions are handled with bytes shifting:)
Moreover Money encapsulates concept of the Currency. You can also add concept of currency ration date.
===Immutability===
VOs are immutable, so  You can pass them to another Aggregate without worrying about Side Effects. For example, prices for OrderedProducts are used by InvoicingService to generate Invoice. Life is simple with immutability.

<code language="java">
public Money multiplyBy(BigDecimal multiplier) {
  return new Money(value.multiply(multiplier), currencyCode);
}
</code>

===Aggregate Inner State Projection===
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderedProduct.java OrderedProduct] Value Object is introduced as an "adapter" that adopts inner aggregate model to the outer world, because we assume that OrderLine model is unstable and will change in the future.


===Make explicit what is implicit===
VOs are little classes that make a difference.
Without VOs Your code suffers from Primitive Obsession Code Smell.
===Increase expression power===
Value objects are small artifacts, but extremely increase power of domain expression. They enrich Ubiquitous Languages and help understand details of the model. 
===JPA aspects=== 
Using VOs is very "cheap" from the perspective of JPA. You don't need any additional tables. Simple map them as @Embededable classes and use in Entitues/Aggregates ad @Embeded.

If You have more than one embedded VO in Entity, You must use additional annotations:

<code language="java">
@Embedded
  @AttributeOverrides({
    @AttributeOverride(name = "value", column = @Column(name = "net_value")),
    @AttributeOverride(name = "currencyCode", column = @Column(name = "net_currencyCode")) })
private Money net;

@Embedded
  @AttributeOverrides({
   @AttributeOverride(name = "value", column = @Column(name = "gros_value")),
  @AttributeOverride(name = "currencyCode", column = @Column(name = "gros_currencyCode")) })
private Money gros;
</code>

Alternatively, You can provide special Naming Strategy in Hibenrate.

----
==Factory==
Sample contains two factories: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/OrderFactory.java OrderFactory] and InvoiceFactory.

<code language="java>
@DomainFactory
public class OrderFactory {

    @Inject
    private RebatePolicyFactory rebatePolicyFactory;
    @Inject
    private InjectorHelper injector;

    public Order crateOrder(Client client) throws OrderCreationException {
        checkIfclientCanPerformPurchase(client);

        Order order = new Order(client, Money.ZERO, OrderStatus.DRAFT);
        injector.injectDependencies(order);

        RebatePolicy rebatePolicy = rebatePolicyFactory.createRebatePolicy();
        order.setRebatePolicy(rebatePolicy);

        addGratis(order, client);

        return order;
    }

  //...
}
</code>

Factories are annotated with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainFactory.java DomainFactory] annotation. This annotation introduces Spring features - factory becomes a Spring bean, therefore You can inject dependencies into the factory and factory can be injected into CommandHandlers.

Now we will discuss responsibility scope of DDD Factories.

===Validation===
Factory is responsible for providing valid Aggregates. Invalid Aggregate can not exist in memory. OrderFactory is responsible for validating 
"components" that build Order - in this sample it checks Client and eventually throws [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/errors/OrderCreationException.java Domain Error].
===Injecting Factories into Command Handlers/Application Services
Factories are need to create Aggregates, therefore You will inject them into Command handlers or other places. It is possible because factory is a Spring Bean
<code language="java>
@CommandHandlerAnnotation
public class CreateOrderCommandHandler implements CommandHandler<CreateOrderCommand, Long> {

  @Inject
  private OrderFactory orderFactory;

  //..
}
</code>
===Injecting into Factory===
Factory may also need some dependencies,  for example Repositories to be able to check something.
<code language="java>
@DomainFactory
public class OrderFactory {

    @Inject
    private RebatePolicyFactory rebatePolicyFactory;
    @Inject
    private InjectorHelper injector;
</code>
For example, OrderFactory adds gratis products to newly created order. Knowledge about gratis comes from DomainService or Repository.

Another example is RebatePolictFactory in OrderFactory to determine rebate.

===Dependency Injection Responsibility===
Aggregates needs dependencies. We decided that Factories and Repositories are responsible for providing them.

In sample code OrderRepository is responsible for injecting RebatePolicy.

<code language="java>
    //..
    public Order crateOrder(Client client) throws OrderCreationException {
        //..
        Order order = new Order(client, Money.ZERO, OrderStatus.DRAFT);
        injector.injectDependencies(order);

        RebatePolicy rebatePolicy = rebatePolicyFactory.createRebatePolicy();
        order.setRebatePolicy(rebatePolicy);

        //..

        return order;
    }

  //...
}
</code>

There are some very common dependencies, like DomainEventsPublisher, which are injected by special [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/support/InjectorHelper.java InjectorHelper].
 
===Part of business logic (Assembling objects)===

Factory is responsible for some domain logic:
  * calculates dependencies - Rebate Policy
  * add gratis product
Therefore it is a First Class Citizen in DDD Building Blocks World.

Read great [http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone post] by Miko Hevery that explains three faces of the coupling:
  * collaboration
  * construction
  * call

Factories lighten application logic layer by taking construction coupling.


===Increase testability=== 

If You construct Aggregate dependencies in factories and then inject them to the Aggregate, You gain another feature - higher testability. Thanks to factories, Aggregates don't have to use new operator (except inner data structures). This means You can easily mock dependencies when unit testing.

----
==Repository==

Project contains few sample Repositories, which are implemented in the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Finfrastructure%2Frepositories%2Fjpa Infrastructure Layer].

Repository is an abstraction of the Aggregate/Entity persistence.
<code language="java">
@DomainRepository
public interface OrderRepository {

    public void persist(Order order);

    public Order save(Order order);

    public Order load(Long orderId);

}
</code>
Therefore Repository has domain interface and technical implementation.
<code language="java">
@DomainRepositoryImpl
public class JpaOrderRepository extends GenericJpaRepositoryForBaseEntity<Order> implements OrderRepository {
  //..
}
</code>


In general, Aggregate parts may origin form different sources.


Repository manages aggregate, which means it must load and save. Don't pollute repositories with dozens of search method - that's the responsibility of the second stack - a Presentation Stack.

Naturally, repository will contain business search methods, like: find draft Orders of the given Client, because we want to apply rebate for them.

===Responsibilities===

In general, Repository is also responsible for stuff that Factory does: a Dependency Injection.

===Base Classes=== 

There are base classes for both Entity and Aggregate repositories in [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Frepo%2Fjpa common DDD goodies].

Implementation is based on the famous [http://www.ibm.com/developerworks/java/library/j-genericdao/index.html Generic DAO] by Per Mellqvist.

----
==Domain Services==
Sometimes it is not natural to just stick some method to the Aggregate.
Moreover, we don't want to our Aggregates become a God Classes, like 8k lines of code monster that knows everything and knows everyone.

There is a [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/InvoicingService.java InvoicingService] sample Domain Service that handles creating Invoices.

<code language="java">
@DomainService
public class InvoicingService {
	
  @Inject
  private ProductRepository productRepository;
	
  public Invoice issuance(Order order, TaxPolicy taxPolicy){
    //..		
  }	
}
</code>
We certainly don't want to add this feature to the Order Aggregate.

Domain Service is annotated by [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/annotations/DomainService.java DomainService] annotation that introduces Spring Bean features. Therefore our Domain Service can be injected and we can inject dependencies to the service (ex. Repositories).

As we can see, InvoicingService looks at the Order Aggregate through a ValueObject "projection" mentioned earlier.

===Responsibility Driven Design Transformers===
Great book [http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430 Responsibility Driven Design] by Rebecca Wirfs-Brock describes standard Building Blocks - more abstract than Evans' DDD BB. 

InvoicingService can be considered as a Transformer role class, that transforms Orders to Invoices.

===When to introduce: simple rule of the thumb=== 

Simple rule of the thumb for beginners. You probably wont miss much, if create Domain Services instead of Aggregate methods for operations that are used on one Use Case/user Story.

It it a procedural way of thinking, but keeps Aggregates coherent and loosely coupled.

That's just a rule for the newbies, so it's intuition that tells when to break it. 

----
==Policy==

Technically Policy is just an old, good [http://en.wikipedia.org/wiki/Strategy_design_pattern Strategy Design Pattern].

In our sample project, we have two behaviors that vary a lot:
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/RebatePolicy.java Rebate Counting] - depends on client, product, whole order, history etc
  * [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/TaxPolicy.java Tax Counting] - depends on client's country, seller country etc

===Make explicit what is implicit===
We want to express those very important domain concepts in the model and treat them as First Class Citizens.

===Supple Design===
Introducing policy opens design for further extension. It also encapsulates complex logic in separated places:
  * Rebate counting resides in specific [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fpolicies%2Frebate implementations]
  * Rebate choosing based on logged user resides in [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/RebatePolicyFactory.java RebatePolicyFactory]
  * Calling rebate is managed by Order Aggregate and delegated to the Order Lines

===Decorating technique===
Suppose we have VIP rebate and Winter rebate. What if VIP buys in winter? Suppose our system composes rebates. Should we introduce a third class to the model?

Sure not! All You need to do is to introduce a [http://en.wikipedia.org/wiki/Decorator_design_pattern Decorator Design Pattern].

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fpolicies%2Frebate%2Fdecorators Sample decorators].

Sample Policy decoration in case System User has a VIP status:
<code language="java">
@DomainFactory
public class RebatePolicyFactory {

  @Inject
  private SystemUser systemUser;
	
  public RebatePolicy createRebatePolicy() {		
    RebatePolicy rebatePolicy = new StandardRebate(10, 1);
		
    if (isVip(systemUser)){
      rebatePolicy = new VipRebate(rebatePolicy, new Money(1000.0), new Money(100));
    }
    return rebatePolicy;
  }
  //..
}
</code>

===Functional style===

Strategy design pattern is semantically similar to the functional style programming. Concept is the same: an operation is as First Class Citizen. In OO language, FCC is an objects. So we simply pack operations into objects with only one method which is a signal to the object saying "execute yourself":

<code language="java">
@DomainPolicy
public interface RebatePolicy {

  public Money calculateRebate(Product product, int quantity, Money regularCost);

}
</code>

===Injecting=== 

In our example, Order Policy is injected to the order Aggregate by the Order Repository and Order Factory.

<code language="java">
@Entity
@Table(name = "Orders")
@DomainAggregateRoot
public class Order extends BaseAggregateRoot {

    @Transient
    private RebatePolicy rebatePolicy;

    //..

    public void setRebatePolicy(RebatePolicy rebatePolicy) {
        if (this.rebatePolicy != null)
            throw new IllegalStateException("Policy is already set! Probably You have logical error in code");
        this.rebatePolicy = rebatePolicy;
    }
}
</code>

Another example:
Tax Policy is passed to the Invoicing Service as a method parameter.

<code language="java">
@DomainService
public class InvoicingService {
	
  @Inject
  private ProductRepository productRepository;
	
  public Invoice issuance(Order order, TaxPolicy taxPolicy){
    //..
  }
</code>
----

==Specification==
[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/application/commands/handlers/SubmitOrderCommandHandler.java SubmitOrderCommandHandler] attempts to submit Order and generate Invoice.

But there are complex constrains, that must be met before Order can be submitted. If you struggle to model constrains that are build by many criterion which are arranged in logic tree, then You may consider using a [http://en.wikipedia.org/wiki/Specification_pattern Specification Pattern]. 

Sample contains [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fdomain%2Fspecification%2Forder Order Specifications] based on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fdomain%2Fsharedcernel%2Fspecification library generic specification]. 

===Supple Design in Runtime===

Power of the specification is that it can be assembled late in the runtime based on the actual context.

Method SubmitOrderCommandHandler.generateSpecification can be refactored to the factory.

<code language="java">
private Specification<Order> generateSpecification(SystemUser systemUser) {
  Specification<Order> specification = new ConjunctionSpecification<Order> (
     new DestinationSpecification(Locale.CHINA),//.not(), // - do not send to China
     new ItemsCountSpecification(100),//max 100 items
     new DebtorSpecification()//not debts or max 1000  => debtors can buy for max 1000
       .or(new TotalCostSpecification(new Money(1000.0))));


  //vip can buy some nice stuff
  if (! isVip(systemUser)){			
    specification = specification.and(new RestrictedProductsSpecification());
  }
		
  return specification;
}
</code>
===Further extension===

If needed, You may extend Specification so that it collects errors.

----
==Domain Events==
In one of the previous chapters, we have discussed Application Events. Technically Domain Events are the same. Difference is one the mental level - Domain Events model facts that takes place in domain model.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/BaseAggregateRoot.java BaseAggregateRoot] contains [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/domain/DomainEventPublisher.java DomainEventPublisher] object which is injected via Repo or Factory. 

Firing event:
  * inject DomainEventPublisher
  * create objects of any class that contains valuable information
  * call publish on publisher

Sample event publishing: submit method of [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/domain/Order.java Order] Aggregate.

<code language="java">
public void submit() {
  checkIfDraft();

  status = OrderStatus.SUBMITTED;
  submitDate = new Timestamp(System.currentTimeMillis());

  eventPubslisher.publish(new OrderSubmittedEvent(getId()));
}
</code>

Listening events:
  * annotate listener method with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListener.java EventListener]
    * Event listener may express intention that it is not interested in immediate execution - asynchronous attribute
  * annotate class containing listener method with [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/ddd/infrastructure/events/EventListeners.java EventListeners] - that will register Spring bean and introduce Dependency Injection support

<code language="java">
@EventListeners
public class OrderSubmittedListener {

  @EventListener(aynchronous=true)
  public void handle(OrderSubmittedEvent event) {
    System.out.println("Sending mail aboud order: " + event.getOrderId());	
  }
}
</code>

Now we will discuss motivations that promotes using Domain Events
===Decoupling===
Events introduce Bounded Contexts decoupling. Context does not know about each other.

Events introduces Technical decoupling. Domain Building blocks does not know about technical listeners (ex. mail/sms senders, facebook publishers;)

Sample: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/infrastructure/events/listeners/domain/OrderSubmittedListener.java OrderSubmittedListener] that fakes sending mail.
===Optimization===
Some listeners may be executed in asynchronous way which reduces request processing time.

Sample: [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/infrastructure/events/listeners/domain/OrderSubmittedListener.java OrderSubmittedListener] that fakes sending mail can be annotated to work in asynchronous mode. 
===Plugin oriented architecture===
Listeners may introduce new features without the need to touch core code.
===Updating read model===
Domain Events can be used to update [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Ferp%2Fsales%2Fpresentation Presentation Model].

You can use this technique when presentation model is implemented as a separate, dedicated model (not Views). You can introduce many presentation model (each per specific case) that are updated by the same Event - just add dedicated updating Listener per model.

In [http://code.google.com/p/ddd-cqrs-sample/source/browse/trunk/ddd_cqrs-sample/src/main/java/pl/com/bottega/erp/sales/presentation/listeners/ProductEventsListener.java this sample] Listener works on Application Event, but idea is the same.

===Event Sourcing===
Domain Events may be stored as a behavioral model. Loading Aggregate loads all its events and executes them on a given aggregate.

Stored events can be "projected" to many "perspectives".
In this case Presentation model must be updated via updating listeners discussed in previous section.

===Complex Event Processing===
You can introduce Event Oriented approach when system/organization need to process event streams and react on event patterns that emerge in time/quantity window.
----
----
=Saga=
Great Saga introduction by Udi Dahan: [http://www.udidahan.com/2009/04/20/saga-persistence-and-event-driven-architectures/ Saga Persistence and Event-Driven Architectures]
==Complex process orchestration==
In general use Saga when You need to orchestrate process that is pushed by many events. Using Saga You can model partial state change of the bigger process - state change triggered by events.
==Persistent multi-listener==

Saga has persistent state and listen to many events.

[http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Finfrastructure%2Fsagas Saga Engine] is described in details in [PART II]. General idea is:
  * Engine catches event
  * Engines find Loaders that are interested in this event
  * Engine asks found Loaders to load/create persistent Mementos
  * Engine feeds relevant Sagas with Mementos
  * Engine calls Saga event handlers
  * Sagas change their state (Memento)
  * Mementos are persisted
  * Sagas may be done

Above scenario is a technical point of view, but it is good to understand it at this level. Business Developer does not have to implement technical steps, they are provided by the Engine. Business 

Developers focus on the [http://code.google.com/p/ddd-cqrs-sample/source/browse/#svn%2Ftrunk%2Fddd_cqrs-sample%2Fsrc%2Fmain%2Fjava%2Fpl%2Fcom%2Fbottega%2Fddd%2Fsagas Saga API] and following domain artifacts:

===Logic===
Create class that implements Saga logic. In this class we focus only on business logic, we don't have to think about engine.
Sample:

Extends base class and use API Annotation.

Each saga listener method must be annotated.

Some (maybe all) methods may try to finish this saga.

TODO

===Data - Memento===

Saga data is simple [http://en.wikipedia.org/wiki/Memento_pattern Memento Design Pattern].

Idea is that Saga class is stateless, state is delegated to the memento.

TODO

===Loader===

Saga loader focuses on funding right memento for Saga Logic based on event. In general finding Memento may rely on different parameters of different events. For each event instance, there may be many matching finders, therefore many mementos, so one event instance can push many sagas.

TODO

==Saga makes explicit what is implicit==
Saga models very complex processes. Modeling them, instead of trying to pretend that they are not so complex, is essential for chaos management in the model and code.